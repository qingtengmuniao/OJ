开始看是哈希，觉得应该是构造一个能找出一个哈希函数，它能将一个雪花特征唯一的映射到一个值。百思而不得其解。按捺不住去看别人的解法，却都是先用简单的加和取模做简单的筛选，经过第一道筛选之后，在用最原始暴力的方法比较——找到个相同的元素，然后从其位置同时顺时针转六格，看看是不是完全一样。不行的话再一顺一逆时针转六格，看看是不是完全一样。大叹暴力啊，然后自己就默默的做了。
却是问题百出。
1. 首先是比较函数，很好写嘛，然后就抬着头掉坑里了。关键在于是同一个方向和不同方向各转一次，我却写成了顺时针一起转一次，逆时针一起转一次。蠢哉！
2. 第二还是比较函数， 顺时针的时候忘了模6了，诶。
int is_same(Arm *a, Arm *b)
{

	int i, j;
	for (i = 0; i < 6; ++i) {
		if (a->arms[i] == b->arms[0]) {
			// clockwise 
			for (j = 0; j < 6; ++j) {
				// mod 6
				if (a->arms[(i+j)%6] != b->arms[j])
					break;
			}
			if (j == 6) return 1;

			// anticlockwise
			for (j = 6; j > 0; --j) {
				// 6-i !!
				if (a->arms[(i+6-j)%6] != b->arms[j%6])
					break;
			}
			if (j == 0) return 1;
		}
	}
	return 0;
}

