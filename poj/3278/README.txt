1. 第一道广搜(BFS)，本来想自己用个短数组循环着用实现一个队列。后来发现，几个基本操作，都得考虑边界清空，判空还不好弄，于是去找C++了。后来看到别人用一个足够长的数组，长到够本题用还不会越界，倒也是一种坚持用C的方法。
2. 开始的时候，想用各种剪枝函数---比如说，是优先乘2还是优先加1啊，想了半天，还想是不是有约束公式。事实证明如此想多了，这的优化远远不如另一个：对一个元素的重复push，你想啊，只要第一个是重复的，以后就会全部重复。所以关键剪枝在于这个visited数组。这也是贡献了超时的原因。
3. 然后另一个注意点就是，当n>k的时候，只有一步一步往后退，因为没有除以2这种步伐，很朴素的想法，所以单独拿出来判断就行了。如果还放到循环里，考虑怎么剪枝，哪怕是脑袋越想越乱。
4. 对于step，可以弄一个关联数组，也可以弄个结构体，其实两个简单int数组和一个结构体数组是一样的，但是后者语义更清楚一些，当然多了些动态申请。

从此题的教训就是，把朴素的明显的剪枝先干完，其实也就差不多了，复杂约束一般来说就是另一个算法考的了。
总结下所有剪枝：边界，明显约束，重复的。
广搜，一般就是循环+队列（层层往外扩）；而深搜一般就是递归（一条路走到黑才返回）。

