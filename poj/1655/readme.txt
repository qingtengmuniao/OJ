1. 这道题，用人家的话说就是求树的重心。
关键在于求每个节点连接的各个子树的节点树，任选一个点作为根进行DFS，我们可以得到除了父亲节点外其他子树的所有节点数。
对于任意一节点i，而去掉该点，带有父亲节点的那棵子树的节点数就是：n-subtree(i)-1.
如此一来用一个dp数组就可以保存i节点所有子树的最大节点数，最后遍历dp数组，求出最小值以及下标就行了。

2. 然而这样一来，根本没有用上dp啊，dp数组就是个名字啊，所以G++超时了。C++过了，也是好几百ms。

3. 后来看人家的代码优化了一下，然后并不是优化的dp，而是优化的邻接表的存储。原先是用stl的vector变长存储的，虽然原则上来说存储空间省了，但是大量的动态添加删除需要的工作量也不小尤其是n=10000级的。所以现在改成了用edge[1..2n]存边（的两个端点），用head存储edge里每个点下标的位置，用next数组存下一个下标位置，每次插入像链表一样，从表头插入，具体的可以看代码。
最后时间由几百ms变成了47ms。
需要注意的一点就是，edge的下标最好从1开始，用0来标识一个链表的结尾，否则边界可能会有问题，然后我就WA了两次。

