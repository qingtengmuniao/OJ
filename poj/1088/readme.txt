1. 这是一道记忆化搜索的动归，他和挖矿工那道题何其的相似，然而我开始并没有想到。
2. 我竟然神奇的把他转化为和最长递增子序列(Longest Increase Subsequence)的解法。我当时是这样想的：如果两个高度a,b，并且a>b，那么a到b上有一条边，这样不就构成一个DAG么。一想还真是，因为序列必须是逐个递减的，不可能有环，否则一个数转一圈大于它自身，岂不扯呼。那么就往LIS上靠吧，看他逐个求解的过程，必须是先求出被依赖的点(前面的点)，然后逐个往后求。那么这道题被依赖的点是啥，或者终极一点想，谁可以不被依赖就可以确定，当然是最高点~ (其实是最低点，那会头脑一热就反着想了，但其实他俩是等价的)，设其距离为1，然后求次高点，它只可能依赖比它高的点来实现递推，而比它高的点之前已经求过了，依次往下... 所有都能像LIS一样求出来。
所以最开始只需要排个序就行了，手写快排呗，然后时间复杂度是O(nlgn)，其次，对于每个点进行迭代求解，复杂度O(n)。总体nlg(n).

其实这种方法就和挖矿工的自底而上的迭代的思路是一样一样的，对比如下:

挖矿工 滑雪
边
树状，上边一个点指向下边左右两点。
网状，指向周围四个点的几个点，当且仅当它的高度高于人家。
迭代解法
自上而下，因为上边依赖下边。用高度排序，然后从最低点往上走。
记忆化搜索
就是递归的时候记下来，本质在于用函数的调用
引发对于dp的填充，而反过来，只要已经填充了
那么就直接返回，前者在于逻辑的通顺，后者在于
时间的节省。
同上。


3. 几点经验教训：
     a. 对于这种类似棋盘的，左右走的，而又非正方形的，在判断是否跑出边界的时候，注意不要搞反。想要弄对很简单，看x,y，在哪一维度进行遍历。
	 b.上下左右移步的，可以将偏移量dx, dy用一个数组写出来，然后四个判断就可以变成循环。

