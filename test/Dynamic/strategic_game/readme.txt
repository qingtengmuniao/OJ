1. 首先吐槽下hsu的oj的编译器，应该是识别的是windows下的文件，因为每次加注释//都报错。

2. 这是一道树形动归。首先去算法概论上看了下相关的东西，他是一笔带过，只讲了dp递推的时候，可以按照树天然的层次。
然而其他并没有收到什么启发，于是又可耻的去看别人的源代码。直到遇到一个有注释的，才晓得dp[N][2]的意思，就是对每个节点放不放士兵进行决策。
那么状态转移方程就呼之欲出了：对于每个节点root
如果该点不放士兵，那么 dp[root][0] = sum{dp[child][1]}, child是所有的root的孩子节点。
如果该点放士兵，那么dp[root][1] = sum{ min{dp[child][1], dp[child][0]} }，该节点放了士兵，孩子节点可放可不放。

3.然后就是利用dfs遍历，其实对于树来说，这种也是层次遍历。所以在进入树根前，对dp[root][0...1]进行初始化，然后逐个遍历其孩子，对dp[root][0...1]进行更新。

4. 他这题每条边就出现一次，注意这个问题。如果用邻接矩按下标存，则复杂度就变成N^2了，所以还是用矩阵按着邻接表的方式存。注意找到根，因为所有边都只存了一次。而普通的树所有的边都能成为根。

