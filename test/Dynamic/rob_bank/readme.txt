1. 这个题真是调到欲吐不能了。
2. 首先是对于dp[i]的定义。在这个题目中，我们有三个量： 单个银行money，单个银行抢劫被抓概率possibility，抢银行总钱数。一般用背包解该题的话，我们用银行i，和不被抓的概率作为背包容量c，逐级增大，那么dp的值就是解，即不被在小于最大不被抓的概率的时候，最多能抢劫多少钱。这样最后dp右下角那个值就是解。
然而概率是不可分的，所以我们只能用银行i，和可以抢的钱的总数，逐级增大，作为dp的两个维度。如此一来，dp的右下角的值就不是问题的解。那么就必须遍历dp这个向量，来找到解。
注意四点：
a. dp[i][j]表示逐个考虑前i个银行后，在最多能抢到j的钱数时，不被抓的最大概率。
b. 首先明确用一维向量来模拟， 初始化： dp[0]初始化1，其余为0，注意其余的0仅仅表示未定状态，并且正好在递推的时候符合dp[j] = max(dp[j], dp[j-m[i]]*(1-p[i])); 而不是表示实际意义。
c.从右边到左边遍历，这样才能找到最大的，因为可能不是单调的，所以从左边找会有问题。
d.转化成不被抓的概率可以直接乘起来，而不用在中递推计算的时候用1来做减法。
3. 让我困扰很久就是交了不对的坑是
void * memset ( void * ptr, int value, size_t num );
我原来一直以为，最后一个num代表数组长度，所以在这里我就用了total_m，谁知却是bytes数，导致想提高点效率，却砸了自己的脚。
最终问题解决是拿一些边界测试数据，来用人家正确代码跑和我的错误代码跑比对出来的。

