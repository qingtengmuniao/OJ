1. 重新认识了下背包的本质，就是两列数，w[i]与v[i], (0 =< i <= n)，在对一列或两列的和或其他的有限制的条件下，求一列或两列的和的极值

	a. 对于最经典的背包，是给定一个w[i]和的上限C，然后求在这个约束下sum(v[i])的最大值：
	经典解法是，对于每个物品i进行决策，去或留，一一进行决策，作为外层循环。
	dp[j]的含义：sum(w[i]) <= j的情况下，所获得的最大sum(v[j])，当j=C的时候，即是该问题的解。所以我们定义的dp就直接是一个个同质的子问题，所有物品决策完一个遍即可以在最后一个格子得到问题的解。
	状态转移方程：dp[j] = max(dp[j], dp[j-w[i]] + v[i])，不要i就是前者，要i就是先装上该物品（获得价值 v[i]），然后剩下的容量最多可以获得多少价值呢？曰：dp[j-w[i]] + v[i]
	初始化：每个dp[j]开始都初始化为0，这既符合dp的含义（所有东西都还没开始决策，自然获得的sum(v[j])为0），也符合由无到有的递推公式，因为v[i]非负，肯定会被装上物品后覆盖。然而，各种bt的变种背包，两个并不一定能满足。那么我们只能求其次，只是符合递推，但是并不能很好的表达dp的初始的时候含义。 要想满足含义，不符合递推。。你想多了吧，还想解题么。
	
	b.对于本问题，约束条件变了，首先有负数了，其次约束条件变为sum(v[i]) >= 0 并且 sum(w[i])>=0，最后求解：sum(v[i]+w[i])的最大值。
	dp[j]含义：仍是（别问我怎么想到的，我不会告诉你就是抄的别人的），sum(w[i]) <= j的情况下，所获得的最大sum(v[j])。
	那么问题来了，w[i]有负数，所以得所有的加一个bias（偏置），使dp不可能出现负值。
	状态转移方程：仍是，dp[j] = max(dp[j], dp[j-w[i]] + v[i])，等等，还没完，j的遍历顺序不一样了:
	当w[i]>0的时候仍是递减，因为j-w[i]减小了，用到position小的dp，所以得从后往前遍历。
	当w[i]<0的时候变成递增，因为j-w[i]增大了，用到position大的dp，所以得从前往后遍历。（ps:因为我们用的是一位数组的dp，要是二维                              数组，那么随你任性吧，不用分情况了。）
	初始化：dp[bias] = 0, 其他初始化为dp可能出现的最小值，对，就是为了满足递推式子：容量为0的背包，自然初始什么都不能容纳。然后其它初始化为最小值，只是为了递推的时候被以后的有效值覆盖掉。所以初始就给了一个有效值那就是dp[bias].

2. 最后dp不是直接和原问题相契合，所以得遍历，初始max_sum为0，正好也是边界条件，然后遍历dp这个vector，然后发现最大的sum(v[i]+w[i]).

