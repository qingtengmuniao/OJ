这个主要是考最小生成树算法，先用Prim实现了一遍。
发现它与Dijkstra最短路径算法很相似，都是从一个新点集合出发，不断加点。而Kruskal算法是不断地添加边。
为什么选择Prim呢，主要在于Kruskal算法的判断回路当时觉得比较麻烦，但是以后也要实现，按下不表。

那么我们来说说Prim算法：
首先，我们必须记下那些点已经被加进V_NEW点集了，可以用一个向量used[N]来表示。
其次，需要记下V_NEW点集作为一个整体，到每个点的距离，注意这的距离的表示肯定最后落在某一条边的边权上，而不是Dijkstra算法的一条路径的所有边的边权。可以用另一个向量dis[N]来表示。然后观察后发现，其实dis[i] = 0，就表示点i在V_NEW集合里，那么used[N]这个向量就可以省了。
最后，对于算法流程，和Dijkstra算法一样，(0) 先选择一个点，反正对起始点没要求，那么就是下标是0的那个点吧，记为now_point=0然后开始迭代。每次迭代分两步，(1) 更新向量dis（由于引入新点带来的作用，开个脑洞，我们可以这么想：对于一个圈子，由于引入了新成员，那么由这个新成员所带来的关系，是否使这个圈子跟世界有了更进一步的联系）(2) 然后遍历向量dis[N]，找出最短距离min_dis，更新now_point。（继续开脑洞：找出离该圈子最近的那个人，拉他入伙）。 然后顺手把这个min_dis加到total_dis上。  等迭代结束，希望不是天荒地老，当然了就是O(N)嘛，然后输出这个total_dis就成。
绕弯弯了的几个点：
1. 开始试图定义一个边的struct，存下边权还拍了个序，后来幡然醒悟，说好的Prim怎么胳膊肘又拐向Kruskal了。好吧，说白了开始还是不熟他们的各自特点。
2. 如果只是求最小生成树的权值，那么没有必要在计算过程中记下拉每个点入伙的顺序。所以自然不需要类似于previous[N]类似的向量了。
3. 每次竟然忘记把total_dis清零了，我说怎么注释那么清楚的算法竟然有错误。
